Esse documento representa parte dos meus estudos acerca do Livro - Operational Systems  Three Easy Pieces, de dominio publico.

# 2.0 Mechanism: Limited Direct Execution

De maneira geral, ao compartilhar tempo da CPU com n processos, nos encontramos com diversos problemas. Entre eles, como podemos manter o controle da CPU, mesmo apos ele ter sido passado para o processo, em caso, por exemplo, um loop infinito dentro em alguma _rotina_ do processo? Podemos ter um problema de performance, visto que determinados processos podem precisar ou nao de mais tempo de CPU tendo outros em vista. 

Diante destas problematicas, podemos inferir que nao se pode apenas virtualizar a CPU sem criterio. Por isso, veremos algumas tecnicas e metodos para tal.

## 2.0.1 limited direct execution
A execucao direta e limitada eh uma tecnica que tem esta sucessao de eventos:

- cria uma entrada na **lista de processos**
- aloca memoria para o programa 
- carrega o programa na memoria principal.
- inicializa a *run-time stack* com os argumentos externos (I.e argc/argv)
- limpa os registradores
    - executa a rotina principal do programa
    - roda o programa
    - retorna um status
- limpa a memoria utilizada 
- remove o processo da lista

Este processo mantem a problematica supracitada, ou ao menos, do jeito que esta.

## 2.0.2 Operacoes restritas

Neste sentido, o programa precisa ter camadas de protecao. Por exemplo, teremos processos designados de escopo de usuario, enquanto ha outros executados em modo kernel. 


### Bonus
> As chamadas de sistema em C, na verdade, sao apenas chamadas de funcao padrao da linguagem, entretanto, com algumas peculiaridades. Elas recebem e armazenam os argumentos e resultados da operacao em registradores e regioes especificas da memoria referente ao processo em si, atraves de um codigo _assembly_ ja escrito. Desta forma, nao precisamos escrever chamadas ao sistema diretamente com assembly, por exemplo.


## Bibliografia
https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf
