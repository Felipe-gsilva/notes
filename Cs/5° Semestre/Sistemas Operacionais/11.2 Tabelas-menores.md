




# tabelas de paginas (lineares) sao enormes
## solucao simples: aumentar cada pagina
podemos reduzir o tamanho simplesmente utilizando de paginas maiores. Se tivermos um address space de 32-bit, podemos usar um VPN de 18-bits e 14 bits para o offset. Assumindo que cada PTE tem 4 bytes, temos $2^{18}$ entries na page table linear. (total 1mb por page table).

Mesmo resolvendo parcialmente o problema, gera-se uma fragmentcao interna tremenda e, ainda assim, o resultado obtido em relacao a espaco nem eh tao satisfatorio.
 
## solucao hibrida: paginacao + segmentacao

Alteramos o registrador de base para guardar o endereco fisico da page table de cada segmento (cada segmento agora tem uma page table). O registrador de bounds agora armazena o final da page table.

O endereco virtual fica mais ou menos assim:
![virtual_address](../../dist/1742848146_grim.png)
Entao, para conseguirmos o endreco do PTE (Page Table Entry), temos algo mais ou menos assim:

```c 
sn = (virtual_address & SEG_MASK) >> SN_SHIFT;
vpn = (virtual_address & VPN_MASK) >> VPN_SHIFT;
AddressOfPTE = Base[sn] + (vpn * sizeof(PTE))
```

A diferenca critica desta solucao esta na presenca de bounds por segmento. Cada reg de bounds guarda o valor maximo valido para acessar em cada segmento. 


## Page-tables Multinivel

## Page-tables invertidas

## Swapping
